<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Infinite Pedal Canvas: IoT Connected</title>
    <style>
        /* --- THEME VARIABLES --- */
        :root {
            --app-bg: #121212;
            --sidebar-bg: #1e1e1e;
            --grid-line: rgba(255, 255, 255, 0.05);
            --accent-color: #ff4444;
            --text-main: #ffffff;
            --text-sub: #aaa;
            --item-bg: #333;
            --item-border: #444;
            --pedal-border: rgba(255,255,255,0.2);
            --grid-size: 50px;
        }

        body.light-mode {
            --app-bg: #f0f0f0;
            --sidebar-bg: #ffffff;
            --grid-line: rgba(0, 0, 0, 0.1);
            --accent-color: #007bff;
            --text-main: #222222;
            --text-sub: #666;
            --item-bg: #e9ecef;
            --item-border: #ced4da;
            --pedal-border: rgba(0,0,0,0.2);
        }

        body { margin: 0; overflow: hidden; background: var(--app-bg); font-family: 'Segoe UI', sans-serif; color: var(--text-main); user-select: none; transition: background 0.3s, color 0.3s; }

        /* --- LAYOUT --- */
        #app-container { display: flex; height: 100vh; width: 100vw; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 300px; background: var(--sidebar-bg); z-index: 100;
            display: flex; flex-direction: column; padding: 20px;
            box-shadow: 2px 0 10px rgba(0,0,0,0.2); overflow-y: auto;
            transition: background 0.3s;
        }
        
        h3 { margin-top: 0; border-bottom: 1px solid var(--item-border); padding-bottom: 10px; display: flex; justify-content: space-between; align-items: center; }
        h4 { margin: 20px 0 10px 0; font-size: 14px; color: var(--text-sub); text-transform: uppercase; letter-spacing: 1px; display: flex; justify-content: space-between; align-items: center; }

        .hardware-item {
            background: var(--item-bg); padding: 8px 10px; margin-bottom: 6px; border-radius: 4px;
            cursor: grab; border: 1px solid var(--item-border); font-size: 13px; color: var(--text-main);
            display: flex; justify-content: space-between; align-items: center;
        }
        .hardware-item:hover { border-color: var(--accent-color); }
        .hardware-item.used { opacity: 0.5; pointer-events: none; filter: grayscale(1); }
        /* Status dot for connection */
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #28a745; margin-right: 8px; }

        .pedal-wrapper { margin-bottom: 8px; background: var(--item-bg); border-radius: 4px; overflow: hidden; border: 1px solid var(--item-border); }
        .pedal-header { padding: 10px; display: flex; align-items: center; justify-content: space-between; border-left: 5px solid transparent; cursor: pointer; color: var(--text-main); }
        .pedal-header:hover { background: rgba(0,0,0,0.1); }
        .pedal-name { font-weight: bold; font-size: 13px; flex-grow: 1; margin-left: 8px; }
        .expand-arrow { font-size: 10px; transition: transform 0.2s; color: var(--text-sub); width: 20px; text-align: center; }
        .pedal-wrapper.open .expand-arrow { transform: rotate(90deg); }

        .preset-container { display: none; background: rgba(0,0,0,0.2); border-top: 1px solid var(--item-border); padding: 8px; flex-direction: column; gap: 4px; }
        .pedal-wrapper.open .preset-container { display: flex; }
        .preset-item { padding: 6px 10px; font-size: 12px; color: var(--text-sub); cursor: pointer; border-radius: 3px; display: flex; justify-content: space-between; }
        .preset-item:hover { background: rgba(0,0,0,0.2); color: var(--text-main); }
        .preset-item.live { color: var(--accent-color); font-weight: bold; }

        button.main-btn { width: 100%; padding: 8px; background: var(--accent-color); color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: bold; margin-bottom: 10px; }
        button.main-btn:hover { opacity: 0.9; }
        button.sm-btn { padding: 4px 8px; background: var(--item-border); border: none; color: var(--text-main); font-size: 11px; border-radius: 3px; cursor: pointer; }
        button.sm-btn:hover { opacity: 0.8; }
        .icon-btn { cursor: pointer; opacity: 0.6; padding: 2px; }
        .icon-btn:hover { opacity: 1; color: var(--accent-color); }

        #viewport { flex-grow: 1; position: relative; overflow: hidden; cursor: grab; }
        #viewport:active { cursor: grabbing; }
        #viewport.drawing-cursor { cursor: crosshair !important; }

        #canvas {
            width: 4000px; height: 4000px;
            background-color: var(--app-bg);
            background-image: 
                linear-gradient(var(--grid-line) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-line) 1px, transparent 1px);
            background-size: var(--grid-size) var(--grid-size);
            position: absolute; transform-origin: 0 0; 
        }

        #pedal-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #knob-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 2; pointer-events: none; }

        .pedal-zone {
            position: absolute; border: 2px solid var(--pedal-border);
            border-radius: 8px; display: flex; align-items: flex-start; justify-content: center;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1); pointer-events: auto;
        }
        .edit-mode .pedal-zone { cursor: grab; border-style: dashed; }
        .pedal-label { background: rgba(0,0,0,0.8); color: #fff; font-size: 12px; padding: 4px 10px; border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; font-weight: bold; margin-top: -2px; pointer-events: none; }

        .knob-wrapper { position: absolute; display: flex; flex-direction: column; align-items: center; width: 90px; pointer-events: auto; transition: top 0.1s, left 0.1s; }
        .edit-mode .knob-wrapper { cursor: move; }
        .knob-wrapper.assigned .knob-body { border-color: var(--accent-color); }

        .knob-body {
            width: 80px; height: 80px; border-radius: 50%;
            background: #222; border: 3px solid #666;
            position: relative; box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transition: border-color 0.3s;
        }
        .knob-pointer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .knob-pointer.smooth { transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1); }
        .knob-pointer::after { content: ''; position: absolute; top: 5px; left: 50%; width: 4px; height: 20px; background: var(--accent-color); transform: translateX(-50%); border-radius: 2px; }
        
        .knob-value {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 14px; pointer-events: none; color: white;
            text-shadow: 0 1px 2px black;
        }
        .knob-input { position: absolute; top: 0; left: 0; width: 80px; height: 80px; opacity: 0; cursor: ns-resize; pointer-events: auto; }
        .edit-mode .knob-input { pointer-events: none; } 
        .knob-name { margin-top: 5px; font-size: 11px; color: var(--text-sub); background: var(--item-bg); padding: 2px 4px; border-radius: 3px; border:1px solid var(--item-border); }

        .knob-del-btn { position: absolute; top: 0; right: 0; width: 20px; height: 20px; background: red; color: white; border-radius: 50%; display: none; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; z-index: 10; font-size: 12px; }
        .edit-mode .knob-del-btn { display: flex; }

        #ghost-rect { position: absolute; border: 2px dashed var(--accent-color); background: rgba(255, 68, 68, 0.1); display: none; z-index: 5; pointer-events: none; }

        /* --- MODAL --- */
        #modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 200; display: none; align-items: center; justify-content: center; }
        #modal-box { background: var(--sidebar-bg); padding: 20px; border-radius: 10px; border: 1px solid var(--item-border); width: 300px; color: var(--text-main); }
        input[type="text"] { width: 90%; padding: 8px; margin-bottom: 15px; background: var(--item-bg); border: 1px solid var(--item-border); color: var(--text-main); border-radius: 4px; }
        .color-grid { display: grid; grid-template-columns: repeat(6, 1fr); gap: 8px; margin-bottom: 20px; }
        .color-swatch { width: 30px; height: 30px; border-radius: 50%; cursor: pointer; border: 2px solid transparent; }
        .color-swatch.selected { border-color: var(--text-main); box-shadow: 0 0 10px var(--text-main); }

        #controls { position: fixed; bottom: 30px; right: 30px; display: flex; gap: 10px; z-index: 100; }
        .fab { width: 50px; height: 50px; border-radius: 50%; background: var(--item-bg); color: var(--text-main); border: 2px solid var(--item-border); font-size: 20px; cursor: pointer; box-shadow: 0 5px 15px rgba(0,0,0,0.2); display: flex; align-items: center; justify-content: center; font-weight: bold;}
        .fab.active { background: var(--accent-color); border-color: white; color: white; }
        #theme-btn { position: absolute; top: 20px; right: 20px; z-index: 101; }
    </style>
</head>
<body class="dark-mode">

    <div id="modal-overlay">
        <div id="modal-box">
            <h3>Configure Pedal</h3>
            <label>Name</label><br><input type="text" id="modal-name-input" placeholder="e.g. Overdrive">
            <label>Color</label><br><div class="color-grid" id="modal-colors"></div>
            <button class="main-btn" onclick="confirmPedalCreation()">Start Drawing</button>
            <button class="main-btn" style="background:#555" onclick="closeModal()">Cancel</button>
        </div>
    </div>

    <button class="fab" id="theme-btn" onclick="toggleTheme()">â˜€</button>

    <div id="app-container">
        <div id="sidebar">
            <h3><span>ðŸŽ› Builder</span></h3>
            <h4>Pedals</h4>
            <div id="pedal-list"></div>
            <button class="main-btn" onclick="openPedalModal()">+ Create New Pedal</button>
            <h4>
                <span>Available Knobs</span>
                <span id="conn-status" style="font-size:10px; color: #888;">Connecting...</span>
            </h4>
            <div id="hardware-list"></div>
        </div>

        <div id="viewport">
            <div id="canvas">
                <div id="pedal-layer"></div>
                <div id="knob-layer"></div>
                <div id="ghost-rect"></div> 
            </div>
        </div>
        
        <div id="controls">
            <button class="fab" onclick="toggleUnits()" id="unit-btn" title="Toggle Units">%</button>
            <button class="fab" onclick="toggleEditMode()" id="edit-btn" title="Edit Mode">ðŸ”§</button>
            <button class="fab" onclick="resetView()" title="Center View">ðŸŽ¯</button>
        </div>
    </div>

    <script>
        // --- 1. CONFIG & STATE ---
        const GRID_SIZE = 50;
        const KNOB_OFFSET = 45; 
        const COLORS = ['#FF6B6B', '#4ECDC4', '#FFE66D', '#1A535C', '#FF9F1C', '#D90368', '#9D4EDD', '#2EC4B6', '#F15BB5', '#00BBF9', '#8ac926', '#888888'];
        
        // --- API CONFIGURATION ---
        const API_BASE = "https://yhoshino.org"; // Relative path, e.g. /v1/...

        let state = {
            scale: 1, pointX: -1500, pointY: -1500, isEditMode: false,
            drawing: false, drawStartX: 0, drawStartY: 0,
            pendingName: "", pendingColor: "",
            pedals: [], knobs: [],
            panning: false, panStartX: 0, panStartY: 0,
            openPedalIds: [],
            unitMode: 0 
        };

        // Hardware is now dynamically populated by the backend
        let hardware = [];
        let telemetryStreams = {}; // Store open SSE connections by ID

        // --- 2. INIT & BACKEND ---
        function init() {
            renderSidebar();
            initModal();
            updateTransform();
            connectAvailabilityStream();
        }

        const viewport = document.getElementById('viewport');
        const canvas = document.getElementById('canvas');

        // --- BACKEND LOGIC ---
        
        // 1. Availability Stream
        function connectAvailabilityStream() {
            const statusSpan = document.getElementById('conn-status');
            const evtSource = new EventSource(`${API_BASE}/v1/interface/available`);
            
            evtSource.onopen = () => { statusSpan.innerText = "Connected"; statusSpan.style.color = "#28a745"; };
            evtSource.onerror = () => { statusSpan.innerText = "Offline"; statusSpan.style.color = "#ff4444"; };

            evtSource.onmessage = (msg) => {
                try {
                    // Backend sends single quotes: {'event':'add'...} -> replace to double for JSON
                    const cleanJson = msg.data.replace(/'/g, '"');
                    const data = JSON.parse(cleanJson);
                    
                    if(data.event === 'add') {
                        if(!hardware.find(h => h.id == data.id)) {
                            hardware.push({ id: data.id, label: `Node ${data.id}` });
                            renderSidebar();
                        }
                    } else if(data.event === 'remove') {
                        hardware = hardware.filter(h => h.id != data.id);
                        // Optional: Mark placed knobs as offline?
                        renderSidebar();
                    }
                } catch(e) { console.error("JSON Error", e); }
            };
        }

        // 2. Command Sending (Throttled)
        let lastSendTime = 0;
        function sendCommand(id, val) {
            const now = Date.now();
            if(now - lastSendTime < 50) return; // Limit to ~20 requests/sec
            lastSendTime = now;

            fetch(`${API_BASE}/v1/interface/command`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ id: id, value: parseFloat(val) })
            }).catch(e => console.error("Command failed", e));
        }

        // 3. Telemetry Streams
        function subscribeTelemetry(nodeId) {
            if(telemetryStreams[nodeId]) return; // Already listening

            // Open stream with 100ms interval
            const src = new EventSource(`${API_BASE}/v1/interface/telemetry?id=${nodeId}&interval=0.1`);
            
            src.onmessage = (msg) => {
                try {
                    const data = JSON.parse(msg.data); // Expects {"id":..., "value":...}
                    updateKnobFromRemote(data.id, data.value);
                } catch(e) { console.error("Telemetry Parse Error", e); }
            };

            telemetryStreams[nodeId] = src;
        }

        function unsubscribeTelemetry(nodeId) {
            if(telemetryStreams[nodeId]) {
                telemetryStreams[nodeId].close();
                delete telemetryStreams[nodeId];
            }
        }

        // Logic to update UI from Telemetry without triggering POST loop
        function updateKnobFromRemote(hwId, val) {
            // Find the UI knob associated with this Hardware ID
            const knob = state.knobs.find(k => k.hwId == hwId);
            if(!knob) return;

            // Update State
            knob.val = val;
            
            // Update UI
            const el = document.getElementById(`ui-${knob.id}`);
            if(el) {
                // Update text
                el.querySelector('.knob-value').innerText = formatValue(val);
                // Update invisible slider (so next drag starts from correct spot)
                el.querySelector('input').value = val;
                // Update visual rotation
                const ptr = el.querySelector('.knob-pointer');
                ptr.classList.add('smooth'); // Animate remote updates
                ptr.style.transform = `rotate(${getRotationDeg(val)}deg)`;
                // Remove smooth class after animation
                setTimeout(() => ptr.classList.remove('smooth'), 250);
            }
        }


        // --- 3. HELPER FUNCTIONS ---
        function toggleTheme() { document.body.classList.toggle('light-mode'); document.getElementById('theme-btn').innerText = document.body.classList.contains('light-mode') ? 'â˜¾' : 'â˜€'; }
        
        function toggleUnits() {
            state.unitMode = (state.unitMode + 1) % 3;
            const labels = ['%', 'Â°', 'r'];
            document.getElementById('unit-btn').innerText = labels[state.unitMode];
            state.knobs.forEach(k => {
                const el = document.getElementById(`ui-${k.id}`);
                if(el) el.querySelector('.knob-value').innerText = formatValue(k.val);
            });
        }

        function formatValue(val) {
            if(state.unitMode === 0) return Math.round(val * 100) + '%';
            if(state.unitMode === 1) return Math.round((val * 300) - 150) + 'Â°';
            if(state.unitMode === 2) return ((val * 5.234) - 2.617).toFixed(3) + 'r';
        }

        function getRotationDeg(val) { return (val * 300) - 150; }
        function snap(val) { return Math.round(val / GRID_SIZE) * GRID_SIZE; }

        // --- 4. VIEWPORT LOGIC ---
        function startDrawing() { state.drawing = true; viewport.classList.add('drawing-cursor'); }
        function updateTransform() { canvas.style.transform = `translate(${state.pointX}px, ${state.pointY}px) scale(${state.scale})`; }

        viewport.onmousedown = (e) => {
            if (e.target.closest('.knob-wrapper') || e.target.closest('.pedal-wrapper') || e.target.closest('#controls') || e.target.closest('.fab')) return;
            if (state.isEditMode && e.target.closest('.pedal-zone')) {
                const zone = e.target.closest('.pedal-zone'); const pedal = state.pedals.find(p => p.id == zone.dataset.id);
                if(pedal) startDraggingPedal(e, pedal, zone); return;
            }
            if (state.drawing) {
                const rect = canvas.getBoundingClientRect();
                const rawX = (e.clientX - rect.left) / state.scale; const rawY = (e.clientY - rect.top) / state.scale;
                state.drawStartX = snap(rawX); state.drawStartY = snap(rawY);
                const ghost = document.getElementById('ghost-rect');
                ghost.style.display = 'block'; ghost.style.left = state.drawStartX + 'px'; ghost.style.top = state.drawStartY + 'px'; ghost.style.width = '0px'; ghost.style.height = '0px';
            } else {
                state.panning = true; state.panStartX = e.clientX - state.pointX; state.panStartY = e.clientY - state.pointY; viewport.style.cursor = 'grabbing';
            }
        };

        window.onmousemove = (e) => {
            if (state.drawing) {
                const rect = canvas.getBoundingClientRect();
                const rawX = (e.clientX - rect.left) / state.scale; const rawY = (e.clientY - rect.top) / state.scale;
                const w = snap(rawX) - state.drawStartX; const h = snap(rawY) - state.drawStartY;
                const ghost = document.getElementById('ghost-rect');
                ghost.style.transform = `translate(${w < 0 ? w : 0}px, ${h < 0 ? h : 0}px)`; ghost.style.width = Math.abs(w) + 'px'; ghost.style.height = Math.abs(h) + 'px';
            } else if (state.panning) {
                state.pointX = e.clientX - state.panStartX; state.pointY = e.clientY - state.panStartY; updateTransform();
            }
        };

        window.onmouseup = () => {
            if (state.drawing) {
                const ghost = document.getElementById('ghost-rect');
                if(ghost.style.display === 'block') {
                    const rect = ghost.getBoundingClientRect(); const canvasRect = canvas.getBoundingClientRect();
                    const w = parseFloat(ghost.style.width); const h = parseFloat(ghost.style.height);
                    if (w > 0 && h > 0) createPedal((rect.left - canvasRect.left)/state.scale, (rect.top - canvasRect.top)/state.scale, w, h);
                    ghost.style.display = 'none';
                }
                state.drawing = false; viewport.classList.remove('drawing-cursor');
            }
            state.panning = false; viewport.style.cursor = state.drawing ? 'crosshair' : 'grab';
        };

        viewport.onwheel = (e) => {
            e.preventDefault();
            const rect = viewport.getBoundingClientRect();
            const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top;
            const worldX = (mouseX - state.pointX) / state.scale; const worldY = (mouseY - state.pointY) / state.scale;
            const delta = -Math.sign(e.deltaY) * 0.1; const newScale = Math.min(Math.max(state.scale + delta, 0.5), 3.0);
            state.pointX = mouseX - worldX * newScale; state.pointY = mouseY - worldY * newScale; state.scale = newScale;
            updateTransform();
        };

        // --- 7. PEDAL LOGIC ---
        function createPedal(x, y, w, h) { state.pedals.push({ id: Date.now(), name: state.pendingName, color: state.pendingColor, x: x, y: y, width: w, height: h, presets: [] }); renderPedals(); renderSidebar(); checkAllKnobAssignments(); }

        function renderPedals() {
            const layer = document.getElementById('pedal-layer'); layer.innerHTML = '';
            state.pedals.forEach(p => {
                const el = document.createElement('div'); el.className = 'pedal-zone'; el.dataset.id = p.id;
                el.style.left = p.x + 'px'; el.style.top = p.y + 'px'; el.style.width = p.width + 'px'; el.style.height = p.height + 'px';
                el.style.backgroundColor = p.color + '40'; el.style.borderColor = p.color;
                el.innerHTML = `<div class="pedal-label" style="background:${p.color}">${p.name}</div>`;
                layer.appendChild(el);
            });
        }

        function startDraggingPedal(e, pedal, el) {
            const startX = e.clientX; const startY = e.clientY; const initialX = pedal.x; const initialY = pedal.y;
            const childKnobs = state.knobs.filter(k => k.pedalId === pedal.id);
            const childInitialPos = childKnobs.map(k => ({ id: k.id, x: k.x, y: k.y }));
            const onMove = (me) => {
                const dx = (me.clientX - startX) / state.scale; const dy = (me.clientY - startY) / state.scale;
                const newX = snap(initialX + dx); const newY = snap(initialY + dy);
                const gridDeltaX = newX - initialX; const gridDeltaY = newY - initialY;
                pedal.x = newX; pedal.y = newY; el.style.left = newX + 'px'; el.style.top = newY + 'px';
                childKnobs.forEach((k, index) => {
                    const initPos = childInitialPos[index]; k.x = initPos.x + gridDeltaX; k.y = initPos.y + gridDeltaY;
                    const kEl = document.getElementById(`ui-${k.id}`); if(kEl) { kEl.style.left = k.x + 'px'; kEl.style.top = k.y + 'px'; }
                });
            };
            const onUp = () => { window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); };
            window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
        }

        function deletePedal(id) {
            if(confirm("Delete this pedal?")) { state.pedals = state.pedals.filter(p => p.id !== id); renderPedals(); renderSidebar(); checkAllKnobAssignments(); }
        }

        // --- 8. PRESET LOGIC ---
        function togglePresetList(id) { if(state.openPedalIds.includes(id)) state.openPedalIds = state.openPedalIds.filter(i => i !== id); else state.openPedalIds.push(id); renderSidebar(); }
        function savePreset(pedalId) {
            const name = prompt("Preset Name:"); if(!name) return;
            const pedal = state.pedals.find(p => p.id === pedalId);
            const pedalKnobs = state.knobs.filter(k => k.pedalId === pedalId);
            const snapshot = pedalKnobs.map(k => ({ id: k.id, val: k.val }));
            pedal.presets.push({ id: Date.now(), name: name, data: snapshot }); renderSidebar();
        }
        function loadPreset(pedalId, presetId) {
            const pedal = state.pedals.find(p => p.id === pedalId); const preset = pedal.presets.find(pr => pr.id === presetId);
            preset.data.forEach(item => {
                const liveKnob = state.knobs.find(k => k.id === item.id);
                if(liveKnob) {
                    liveKnob.val = item.val;
                    // Send to backend
                    sendCommand(liveKnob.hwId, item.val);
                    // Update UI
                    updateKnobFromRemote(liveKnob.hwId, item.val);
                }
            });
        }
        function deletePreset(pedalId, presetId) {
            const pedal = state.pedals.find(p => p.id === pedalId); pedal.presets = pedal.presets.filter(pr => pr.id !== presetId); renderSidebar();
        }

        // --- 9. KNOB LOGIC ---
        function checkAllKnobAssignments() { state.knobs.forEach(k => { const el = document.getElementById(`ui-${k.id}`); if (el) checkKnobAssignment(k, el); }); }
        function checkKnobAssignment(knob, knobElement) {
            const kx = knob.x + 45; const ky = knob.y + 45; let assignedId = null;
            for (let i = state.pedals.length - 1; i >= 0; i--) { const p = state.pedals[i]; if (kx >= p.x && kx <= p.x + p.width && ky >= p.y && ky <= p.y + p.height) { assignedId = p.id; break; } }
            knob.pedalId = assignedId; const body = knobElement.querySelector('.knob-body');
            if (assignedId) { knobElement.classList.add('assigned'); const pedal = state.pedals.find(p => p.id === assignedId); body.style.borderColor = pedal ? pedal.color : '#fff'; }
            else { knobElement.classList.remove('assigned'); body.style.borderColor = '#666'; }
        }

        canvas.ondragover = (e) => e.preventDefault();
        canvas.ondrop = (e) => {
            e.preventDefault(); const hwId = e.dataTransfer.getData('hwId');
            if (hwId) {
                const rect = canvas.getBoundingClientRect();
                const rawX = (e.clientX - rect.left) / state.scale; const rawY = (e.clientY - rect.top) / state.scale;
                addKnob(hwId, snap(rawX) - KNOB_OFFSET, snap(rawY) - KNOB_OFFSET);
            }
        };

        function addKnob(hwId, x, y) {
            const hw = hardware.find(h => h.id == hwId);
            if(!hw) return;
            const knob = { id: Date.now(), hwId: hw.id, name: hw.label, val: 0.5, x: x, y: y, pedalId: null };
            state.knobs.push(knob); 
            renderSidebar(); 
            renderKnob(knob);
            subscribeTelemetry(hw.id); // START TELEMETRY
        }

        function deleteKnob(id) {
            const knob = state.knobs.find(k => k.id === id);
            if(knob) unsubscribeTelemetry(knob.hwId); // STOP TELEMETRY
            state.knobs = state.knobs.filter(k => k.id !== id);
            const el = document.getElementById(`ui-${id}`); if(el) el.remove();
            renderSidebar();
        }

        function renderKnob(knobData) {
            const wrapper = document.createElement('div'); wrapper.className = 'knob-wrapper';
            wrapper.id = `ui-${knobData.id}`; wrapper.style.left = knobData.x + 'px'; wrapper.style.top = knobData.y + 'px';
            wrapper.innerHTML = `
                <div class="knob-del-btn" onclick="deleteKnob(${knobData.id})">Ã—</div>
                <div class="knob-body">
                    <div class="knob-pointer" style="transform: rotate(${getRotationDeg(knobData.val)}deg)"></div>
                    <div class="knob-value">${formatValue(knobData.val)}</div>
                    <input class="knob-input" type="range" min="0" max="1" step="0.001" value="${knobData.val}">
                </div>
                <div class="knob-name" contenteditable="true">${knobData.name}</div>
            `;
            checkKnobAssignment(knobData, wrapper);
            wrapper.onmousedown = (e) => {
                if(e.target.classList.contains('knob-del-btn')) return; 
                if (state.isEditMode) { e.stopPropagation(); startDraggingKnob(e, wrapper, knobData); }
            };
            const input = wrapper.querySelector('input'); const pointer = wrapper.querySelector('.knob-pointer'); const valDisplay = wrapper.querySelector('.knob-value');
            
            input.oninput = (e) => {
                const val = parseFloat(e.target.value);
                knobData.val = val; 
                pointer.style.transform = `rotate(${getRotationDeg(val)}deg)`; 
                valDisplay.innerText = formatValue(val);
                sendCommand(knobData.hwId, val); // SEND TO BACKEND
            };
            document.getElementById('knob-layer').appendChild(wrapper);
        }

        function startDraggingKnob(e, el, data) {
            const startX = e.clientX; const startY = e.clientY; const initX = data.x; const initY = data.y;
            const onMove = (me) => {
                const dx = (me.clientX - startX) / state.scale; const dy = (me.clientY - startY) / state.scale;
                data.x = snap(initX + dx + KNOB_OFFSET) - KNOB_OFFSET; data.y = snap(initY + dy + KNOB_OFFSET) - KNOB_OFFSET;
                el.style.left = data.x + 'px'; el.style.top = data.y + 'px';
                checkKnobAssignment(data, el);
            };
            const onUp = () => { window.removeEventListener('mousemove', onMove); window.removeEventListener('mouseup', onUp); };
            window.addEventListener('mousemove', onMove); window.addEventListener('mouseup', onUp);
        }

        // --- 10. SIDEBAR RENDER ---
        function renderSidebar() {
            const hwList = document.getElementById('hardware-list'); hwList.innerHTML = '';
            hardware.forEach(hw => {
                const isUsed = state.knobs.find(k => k.hwId == hw.id);
                const item = document.createElement('div'); item.className = `hardware-item ${isUsed ? 'used' : ''}`;
                // Status dot (green if we are connected, but for now just visual)
                const dot = `<div class="status-dot"></div>`;
                item.innerHTML = `<span>${dot} ${hw.label}</span>`;
                item.draggable = !isUsed;
                item.ondragstart = (e) => e.dataTransfer.setData('hwId', hw.id);
                hwList.appendChild(item);
            });

            const pedalList = document.getElementById('pedal-list'); pedalList.innerHTML = '';
            state.pedals.forEach(p => {
                const isOpen = state.openPedalIds.includes(p.id);
                const wrapper = document.createElement('div'); wrapper.className = `pedal-wrapper ${isOpen ? 'open' : ''}`;
                let presetHTML = `<div class="preset-item live">Current State</div>`;
                p.presets.forEach(pr => {
                    presetHTML += `<div class="preset-item" onclick="loadPreset(${p.id}, ${pr.id})"><span>${pr.name}</span><span class="preset-del" onclick="event.stopPropagation(); deletePreset(${p.id}, ${pr.id})">Ã—</span></div>`;
                });
                wrapper.innerHTML = `
                    <div class="pedal-header" style="border-left-color:${p.color}" onclick="togglePresetList(${p.id})">
                        <span class="expand-arrow">â–¶</span><span class="pedal-name">${p.name}</span><span class="icon-btn" onclick="event.stopPropagation(); deletePedal(${p.id})">ðŸ—‘</span>
                    </div>
                    <div class="preset-container">${presetHTML}<button class="sm-btn" onclick="savePreset(${p.id})">+ Save Current State</button></div>
                `;
                pedalList.appendChild(wrapper);
            });
        }

        function toggleEditMode() { state.isEditMode = !state.isEditMode; document.getElementById('edit-btn').classList.toggle('active'); canvas.classList.toggle('edit-mode'); }
        function resetView() { canvas.style.transition = 'transform 0.5s ease'; state.pointX = -1500; state.pointY = -1500; state.scale = 1; updateTransform(); setTimeout(() => { canvas.style.transition = 'none'; }, 500); }
        function initModal() { const grid = document.getElementById('modal-colors'); COLORS.forEach(c => { const d = document.createElement('div'); d.className = 'color-swatch'; d.style.backgroundColor = c; d.onclick = () => { document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected')); d.classList.add('selected'); state.pendingColor = c; }; grid.appendChild(d); }); }
        function openPedalModal() { document.getElementById('modal-overlay').style.display = 'flex'; document.getElementById('modal-name-input').value = ''; document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected')); state.pendingColor = COLORS[0]; document.querySelectorAll('.color-swatch')[0].classList.add('selected'); }
        function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
        function confirmPedalCreation() { const name = document.getElementById('modal-name-input').value; if(!name) return alert("Enter a name"); state.pendingName = name; closeModal(); startDrawing(); }

        init();
    </script>
</body>
</html>
